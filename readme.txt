Симуляция созданная по мотивам https://my-js.org/docs/guide/shorelark
Simulation запускается с использованием заданной конфигурации Config и со случайных значений (random).
При этом генерируется мир World (World::random).
Конфигурацию можно прочесть (config) и установить новую (set_config), но при этом мир заново
генерируется случайно.
Как и в оригинале, мир World состоит из птичек Vec<Animal> и еды Vec<Food>, которые при запуске
симуляции генерируются случайно (World::random). Мир можно прочесть (world).
Food очень простая, имеет координаты (position) и генерируется случайно.
Animal сложнее и состоит из координат (position), поворота в пространстве (rotation),
скорости перемещения (speed). Также у неё иммеются обзор по еде (vision_f) и другим птичкам (vision_a).
Обзор делится на несколько Секторов, в каждом из них содержится значения "концентрация еды" (<Vec<f32>)
и "концентрация и номер наиболее концентрированной птички" (Vec<(usize, f32)>).
Всё приводится в движение шагом Simulation (step), в котором происходит несколько процессов по очереди:
- process_collisions - столкновения с едой
- process_brains     - мышление
- process_movements  - само перемещение
- try_evolving       - обучение новой популяции
В процессе столкновения с едой (process_collisions) у Animal увеличивается насыщение (satiation).
Food исчезает и генерируется (position) случайно новая.
В процессе мышления (process_brains) у Animal происходит видение (process_vision), обновляются значения
обзоров (vision_f и vision_a). Это получается в результате работы объекта зрения Eye
(process_vision_food и process_vision_animal). После этого у Animal происходит обдумывание увиденного
(process_brain). Это получается в результате работы объекта мышления FlexBrain (propagate_0).
Значения Animal (rotation и speed) заполняются по результатам этого обдумывания.
В процессе перемещения (process_movements) у Animal происходит непосредственно движение (process_movement)
где у Animal обновляются координаты (position) исходя из новых значений (rotation и speed).
В самом конце происходит процесс обучения (try_evolving), который увеличивает возраст (age) у Simulation
и как только он достигнет определенного значения, то происходит цикл обучения (evolve). Сделано
это специально, чтобы Animal накопили насыщенность, чтобы её можно было оценивать.
Цикл обучения (evolve) - сложный процесс. В нем:
1) сбрасывается (age) у Simulation, увеличивает номер поколения (generation), который просто для
информации. После этого рассчитывается средняя насыщенность каждой Animal (satiation_avg) за весь её
возраст (generation_age).
2) Создается генетический алгоритм обучения GeneticFlexAlgorithm. Он реализует алгоритм селекции:
ga::RouletteWheelSelection, алгоритм кроссовера ga::UniformCrossover и алгоритм мутации
ga::Flex1Mutation.
3) Animal переводится в вид удобный для алгоритма обучения AnimalIndividual через (from_animal). Он
реализует трейт ga::Individual и ga::IndividualFlex, который отвечает за ГА обучения.
4) У алгоритма GeneticFlexAlgorithm вызывается само обучение (evolve), которое отдает новую популяцию
птичек в виде Vec<AnimalIndividual> и статистику по предыдущему поколению птичек Statistics.
5) Птички в World замещаются на новых, если они были (changed) путем преобразования AnimalIndividual в
Animal через (from_chromosome). Если замещения нет, просто обновляется насыщение (satiation).
Также обновляется время жизни Animal (generation_lifetime), который при замещении обнуляется, а иначе
берется из AnimalIndividual. Каждая птичка может жить несколько поколений (генерируется случайно).
Время жизни в поколениях уменьшаем для "плохих" птичек, при этом "хорошие" птички сохраняют свою жизнь
дольше.
6) Цикл обучения отдает на выходе статистику по предыдущему поколению птичек Statistics.

Требует проектов genetic-algorithm и neural-network